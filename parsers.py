import black
from io import StringIO
from docx import Document
import PyPDF2

''' Custom output parsers to extract specific pieces of information from LLM outputs'''
class ActionPlanParser:
    '''An Output Parser to parse the action plan provided by LLM in a specific format'''
    def __init__(self,text:str) -> dict:
        self.text = text
        self.tasks = {}
        current_task = None
        for line in text.splitlines():
            line = line.strip()
            if line.startswith("Task "):
                current_task = line
                self.tasks[current_task] = []
            elif current_task and line:
                self.tasks[current_task].append(line)

    def format_parsed_output(self) -> str:
        formatted_output = []
        for task, steps in self.tasks.items():
            formatted_output.append(f"{task}:")
            for step in steps:
                formatted_output.append(f"  {step}")
        return "\n".join(formatted_output)

'''
action_plan = """
Task 1: Create Dev Environment
- Set up virtual environment
- Install necessary packages
- Configure IDE

Task 2: Design Database Schema
- Define tables and relationships
- Create ER diagrams
- Review schema with team

Task 3: Implement Authentication
- Set up user model
- Integrate with OAuth
- Create login and registration endpoints
"""
action_plan_parser = ActionPlanParser(action_plan)


Sample code on how to use the action plan output parser
@parser_job
def test_job(task,steps):
    print("Task : {}".format(task))
    print("Steps: {}".format(steps))
test_job()
'''

class CodeParser:
    """A Custom Output parser to format and indent code generated by llm"""
    def __init__(self,code):
        self.code = code

def format_code(code):
    cleaned_code = code.replace('\\n', '\n').replace('\n', '\n')
    lines = cleaned_code.split('\n')
    formatted_lines = []
    indent_level = 0
    indent_size = 4
    for line in lines:
        stripped_line = line.strip()
        if not stripped_line:
            continue
        # Adjust indent level
        if stripped_line.endswith(':'):
            formatted_lines.append(' ' * indent_level * indent_size + stripped_line)
            indent_level += 1
        elif stripped_line in ['else:', 'elif:', 'except:', 'finally:']:
            indent_level -= 1
            formatted_lines.append(' ' * indent_level * indent_size + stripped_line)
            indent_level += 1
        else:
            formatted_lines.append(' ' * indent_level * indent_size + stripped_line)
            if stripped_line and stripped_line[-1] == ')':
                indent_level = max(0, indent_level - 1)
    return '\n'.join(formatted_lines)
    formatted_code = format_code(lines)

def indent_code(code_string, num_spaces=4):
    indented_code = ""
    indentation_level = 0
    ignore_next_newline = False

    for line in code_string.split("\n"):
        line = line.strip()
        if not line:
            if ignore_next_newline:
                ignore_next_newline = False
                continue
            else:
                indented_code += "\n"
                continue

        if line.endswith("{"):
            indented_code += " " * (num_spaces * indentation_level) + line + "\n"
            indentation_level += 1
            ignore_next_newline = True
        elif line.startswith("}"):
            indentation_level -= 1
            indented_code += " " * (num_spaces * indentation_level) + line + "\n"
        else:
            indented_code += " " * (num_spaces * indentation_level) + line + "\n"

    return indented_code

class DocumentParser:
    def __init__(self,doc_path:str):
        self.doc_path = doc_path

    def word_parse(self) -> str:
        doc = Document(self.doc_path)
        full_text = []
        for p in doc.paragraphs:
            full_text.append(p.text)
        return '\n'.join(full_text)
    
    def pdf_parse(self) -> str:
        pdf = PyPDF2.PdfReader(self.doc_path)
        num_pages = len(pdf.pages)
        full_text = []
        for page_num in range(num_pages):
            page = pdf.pages[page_num]
            curr_page_text = page.extract_text()
            full_text.append(curr_page_text)
        return '\n'.join(full_text)